Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук


Кафедра програмної інженерії



ЗВІТ
до лабораторної роботи №4
з дисципліни «Архітектура програмного забезпечення»
на тему «Розробка програмної архітектури та створення і відлагодження програмного коду мобільного пристрою для програмної
системи»



Виконала:
ст. гр. ПЗПІ-22-6,
Горішня Катерина Олексіївна


Перевірив:
ст. викладач каф. ПІ,
Сокорчук Ігор Петрович


Харків 2025


1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін
1	24.05.2025	0.1	Створено титульну сторінку та розділ «Опис виконаної роботи»
2	26.05.2025	0.2	Додано Додаток Б, 
розділ «Завдання» та «Висновки»
3	27.05.2025	0.3	Додано Додаток В
4	07.06.2025	0.4	Додано посилання на відео та хронологічний опис у Додаток А

		
2 ЗАВДАННЯ
Завдання до лабораторної роботи №4:
1.	Розробити архітектуру мобільного клієнта для програмної системи інтелектуального освітлення, що забезпечує автоматизоване керування освітленням на основі IoT-пристроїв.
2.	Реалізувати мобільний додаток, що надає користувачу можливість авторизації, перегляду списку пристроїв, керування освітленням, редагування сценаріїв, перегляду історії подій і аналітики енергоспоживання.
3.	Реалізувати логіку push-сповіщень для отримання повідомлень про зміну стану пристроїв або помилки в роботі системи.
4.	Забезпечити взаємодію мобільного додатку з серверною частиною системи через REST API: отримання даних про пристрої, збереження розкладів, обробка подій, зчитування статистики.
5.	Імплементувати механізми захисту персональних даних користувача: автентифікацію через JWT-токени, зберігання токена в безпечному сховищі мобільного пристрою, обмеження доступу до ресурсів відповідно до ролі.
6.	Розробити та оформити UML-діаграми, що ілюструють архітектуру вебклієнта: діаграму прецедентів (Use Case Diagram), діаграму компонентів (Component Diagram), діаграму взаємодії (Sequence Diagram), діаграму станів (State Diagram).
7.	Провести функціональне тестування мобільного додатку, перевірити основні сценарії: логін, перегляд пристроїв, редагування графіків, перегляд аналітики, обробка сповіщень і помилок.
8.	Записати та опублікувати на YouTube відео з поясненням реалізованих функцій мобільного застосунку, архітектурних рішень та взаємодію з сервером клієнтської частини.
9.	Оформити звіт, що містить повний опис виконаної роботи, специфікацію реалізованих функцій, UML-діаграми, результати тестування, висновки та додатки з фрагментами коду.
10.	Завантажити звіт у форматі PDF на платформу dl.nure.ua та додати посилання на відео в коментар до роботи.

 
3 ОПИС ВИКОНАНОЇ РОБОТИ
У ході виконання лабораторної роботи було розроблено мобільний клієнт програмної системи інтелектуального освітлення, що дозволяє користувачам взаємодіяти з IoT-пристроями, переглядати статус системи, змінювати сценарії освітлення, переглядати історію подій та аналітику енергоспоживання. 
Мобільний додаток реалізовано з використанням мов програмування Java та Kotlin, що дозволяє створити нативний застосунок для операційної системи Android із доступом до системних ресурсів та API пристрою.
Архітектура мобільного додатку побудована за компонентним принципом. Кожна функціональна частина винесена в окремий модуль або екран: керування пристроями, редагування розкладів, перегляд історії, перегляд аналітики, робота з push-сповіщеннями тощо. Вся взаємодія з серверною частиною реалізована через HTTP-запити до REST API, а з іншими частинами системи, зокрема базою даних і аналітичним модулем, – опосередковано через серверну логіку, що дозволяє мобільному додатку отримувати та відправляти дані про пристрої, графіки, аналітику та користувацькі дії.
Для забезпечення безпечної авторизації реалізовано механізм роботи з JWT-токенами, які зберігаються в локальному безпечному сховищі. Роль користувача враховується при побудові інтерфейсу – адміністративні функції доступні лише після авторизації користувача з відповідними правами. Також реалізовано обробку помилок при з’єднанні з сервером та відсутності доступу до інтернету, що забезпечує стабільність користувацького досвіду.
Під час розробки було створено набір UML-діаграм, що відображають архітектурні рішення мобільного клієнта. Діаграма прецедентів (рис. Б.1) описує основні дії, які доступні користувачу, включаючи перегляд статусу, зміну графіків, керування пристроями та отримання сповіщень. Діаграма компонентів (рис. Б.2) демонструє структуру додатку на рівні логічних модулів і сервісів, включаючи AuthModule, NotificationHandler, ScheduleManager та API Service. Діаграма взаємодії (рис. Б.3) описує процес збереження нового графіка освітлення, від ініціації користувачем до оновлення бази даних на сервері. Діаграма станів (рис. Б.4) моделює зміну станів додатку: від запуску, логіну, до керування пристроями та обробки помилок.
Уся система протестована вручну – перевірено роботу авторизації, керування пристроями, редагування графіків, отримання сповіщень, перегляду статистики. Робота демонструє повноцінний життєвий цикл розробки мобільного застосунку, що охоплює архітектуру, реалізацію, безпеку, інтеграцію з backend-частиною та тестування.
 

4 ВИСНОВКИ
У результаті виконання лабораторної роботи було створено мобільний клієнт програмної системи інтелектуального освітлення, що дозволяє користувачам у зручній формі керувати IoT-пристроями, переглядати статус системи, редагувати розклади освітлення, отримувати push-сповіщення та аналізувати споживання енергії. Розроблений додаток забезпечує повноцінну взаємодію з серверною частиною системи через REST API, підтримує автентифікацію з використанням JWT-токенів і реалізує рольовий доступ до функціоналу.
Отримано практичні навички створення архітектури мобільного додатку, розробки інтерфейсів користувача, організації безпечного зберігання даних на мобільному пристрої, а також обробки помилок і сповіщень. Побудовані UML-діаграми відображають архітектурні рішення та логіку роботи клієнтської частини. Реалізоване програмне забезпечення відповідає функціональним вимогам та успішно пройшло тестування.

 
ДОДАТОК А
ВІДЕОЗАПИС

Відеозапис доповіді на YouTube: https://youtu.be/tEyh5pDMrBM
Хронологічний опис доповіді:
00:00 – Вступ. Опис теми проєкту
00:31 – Опис використаних технологій для розробки мобільного застосунка
01:19 – Опис архітектури мобільного застосунка
04:15 – Тестування роботи мобільного додатка
04:40 – Тестування авторизації користувачів
05:17 – Огляд головного екрана
05:40 – Тестування функціоналу додавання
06:03 – Огляд сторінки деталей пристрою, редагування пристрою
07:15 – Тестування функціоналу створення та видалення розкладів
08:20 – Огляд сторінки аналітики


ДОДАТОК Б
ГРАФІЧНІ МАТЕРІАЛИ

Рисунок Б.1 - UML діаграма прецедентів
 
Рисунок Б.2 - Діаграма компонентів

Рисунок Б.3 - Діаграма взаємодії
 
Рисунок Б.4 - Діаграма станів 


ДОДАТОК В
ПРОГРАМНИЙ КОД

В.1 Математична обробка прикладних даних
GitHub репозиторій: https://github.com/NureHorishniaKateryna/apz-pzpi-22-6-horishnia-kateryna/blob/main/Lab4/pzpi-22-6-horishnia-kateryna-lab4/app/src/main/java/ua/nure/apz/DeviceScheduleActivity.java

 1       private void showAddScheduleDialog() {
 2           AlertDialog.Builder builder = new AlertDialog.Builder(this);
 3           builder.setTitle(R.string.add_schedule);
 4   
 5           int[] time = new int[2];
 6   
 7           LinearLayout layout = new 
              LinearLayout(DeviceScheduleActivity.this);
 8           layout.setOrientation(LinearLayout.VERTICAL);
 9   
10           Button startTimeButton = new Button(DeviceScheduleActivity.this);
11           startTimeButton.setText(String.format(getString
               (R.string.start_time_fmt), 0, 0));
12           layout.addView(startTimeButton);
13   
14           Button endTimeButton = new Button(DeviceScheduleActivity.this);
15           endTimeButton.setText(String.format(getString
               (R.string.end_time_fmt), 0, 0));
16           layout.addView(endTimeButton);
17   
18           builder.setView(layout);
19   
20           startTimeButton.setOnClickListener(v -> {
21               new TimePickerDialog(DeviceScheduleActivity.this, (picker, 
                   hour, minute) -> {
22                   time[0] = hour * 3600 + minute * 60;
23                   ((Button)v).setText(String.format(getString
                       (R.string.start_time_fmt), hour, minute));
24               }, 0, 0, true).show();
25           });
26   
27           endTimeButton.setOnClickListener(v -> {
28               new TimePickerDialog(DeviceScheduleActivity.this, (picker, 
                   hour, minute) -> {
29                   time[1] = hour * 3600 + minute * 60;
30                   ((Button)v).setText(String.format(getString
                       (R.string.end_time_fmt), hour, minute));
31               }, 0, 0, true).show();
32           });
33   
34           builder.setPositiveButton(R.string.add, (dialog, which) -> {
35               CreateScheduleRequest newItem = new 
                   CreateScheduleRequest(time[0]/3600, time[1]/3600);
36   
37               apiService.addSchedule(authToken, deviceId, 
                   newItem).enqueue(new Callback<>() {
38                   @Override
39                   public void onResponse(@NonNull Call<ScheduleItem> call, 
                       @NonNull Response<ScheduleItem> response) {
40                       if (response.isSuccessful() && response.body() != null) {
41                           scheduleItems.add(response.body());
42                           adapter.notifyItemInserted(scheduleItems.size() - 1);
43                       } else {
44                           Toast.makeText(DeviceScheduleActivity.this, 
                               R.string.add_failed, Toast.LENGTH_SHORT).show();
45                       }
46                   }
47   
48                   @Override
49                   public void onFailure(@NonNull Call<ScheduleItem> call, 
                      @NonNull Throwable t) {
50                       Toast.makeText(DeviceScheduleActivity.this, 
                           R.string.add_failed, Toast.LENGTH_SHORT).show();
51                   }
52               });
53           });
54   
55           builder.setNegativeButton(R.string.cancel, null);
56           builder.show();
57       }

