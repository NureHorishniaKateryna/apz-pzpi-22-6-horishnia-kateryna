Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук


Кафедра програмної інженерії



ЗВІТ
до лабораторної роботи №2
з дисципліни «Архітектура програмного забезпечення»
на тему «Розробка програмної архітектури, створенння та відлагодження
 програмного коду серверної частини програмної системи»



Виконала:
ст. гр. ПЗПІ-22-6,
Горішня Катерина Олексіївна


Перевірив:
ст. викладач каф. ПІ,
Сокорчук Ігор Петрович


Харків 2025


1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін
1	24.05.2025	0.1	Створено титульну сторінку та розділ «Опис виконаної роботи»
2	26.05.2025	0.2	Додано Додаток Б, 
розділ «Завдання» та «Висновки»
3	27.05.2025	0.3	Додано Додаток В
4	06.06.2025	0.4	Додано посилання на відео та хронологічний опис у Додаток А

		
2 ЗАВДАННЯ
Завдання до лабораторної роботи №2:
1.	Потрібно розробити серверну / back-end частину програмної системи.
2.	Розробити серверну частину програмної системи інтелектуального освітлення з підтримкою CRUD-операцій для основних сутностей.
3.	Реалізувати REST API для взаємодії між клієнтською частиною, мобільним додатком і сервером, з підтримкою фільтрації, пагінації, авторизації на основі JWT та обмеженням доступу за ролями (користувач, адміністратор).
4.	Забезпечити обробку даних від IoT-пристроїв (датчиків руху), їх збереження, а також запуск і припинення сценаріїв освітлення залежно від подій у приміщенні.
5.	Реалізувати систему сповіщень для інформування користувачів про зміну стану пристроїв або активацію сценаріїв, а також підтримку журналу подій.
6.	Створити механізм резервного копіювання конфігурацій системи та можливість відновлення даних із архівів.
7.	Побудувати UML-діаграми, які відображають архітектуру та структуру системи: ER-діаграму, Use Case діаграму, Deployment діаграму, Component діаграму, структуру бази даних.
8.	Провести тестування API: перевірити коректність запитів, автентифікацію, логіку сценаріїв, взаємодію з базою даних, роботу з правами доступу та відновлення даних із резервних копій.
9.	Оформити звіт за результатами лабораторної роботи, який має містити аналіз завдання, архітектурний опис, специфікацію API, UML-діаграми, текстовий опис реалізації, фрагменти коду, результати тестування та висновки.
10. Завантажити звіт у PDF-форматі на платформу dl.nure.ua, додавши посилання на демонстраційне відео функціоналу системи. 


3 ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Оопис архітектури системи
Архітектура програмної системи побудована за класичною клієнт-серверною моделлю, що забезпечує чіткий розподіл відповідальностей між різними компонентами. Основна ідея цієї архітектури полягає у виділенні клієнтської частини, яка відповідає за взаємодію з користувачем, і серверної частини, яка реалізує бізнес-логіку та управління даними. Такий підхід дозволяє досягти високої гнучкості, масштабованості, модульності та безпеки, що особливо важливо для систем, які працюють із персональними даними користувачів і підключеними IoT-пристроями.
У реалізованій системі клієнт представлений у вигляді мобільного або вебзастосунку, який дозволяє користувачам здійснювати авторизацію, додавати й редагувати пристрої, переглядати інформацію про стан освітлення, керувати конфігураціями, переглядати звіти про використання електроенергії та керувати графіками автоматичного увімкнення/вимкнення світла. Клієнт надсилає запити до серверної частини через RESTful API, забезпечуючи таким чином інтуїтивно зрозумілий і стандартизований спосіб взаємодії.
Серверна частина реалізована за допомогою мікрофреймворку Flask на мові програмування Python. Вона відповідає за обробку запитів від клієнта, виконання бізнес-логіки, аутентифікацію та авторизацію користувачів (через JWT — JSON Web Token), взаємодію з базою даних, обробку даних із сенсорів, генерацію аналітики та адміністрування користувацьких облікових записів. Усі запити до серверної частини проходять через систему перевірки автентичності, що запобігає несанкціонованому доступу до ресурсів системи.
База даних у системі побудована на основі PostgreSQL – реляційної СУБД, яка забезпечує надійне зберігання структурованих даних. У ній зберігається інформація про користувачів, пристрої, конфігурації пристроїв, графіки роботи, звіти про активацію освітлення та інші пов’язані дані. Взаємодія між серверною частиною і базою даних реалізована через ORM-бібліотеку SQLAlchemy, що дозволяє працювати з базою даних у вигляді об'єктів і зменшує ймовірність помилок під час виконання SQL-запитів.
Також система використовує протокол MQTT для обміну повідомленнями з підключеними IoT-сенсорами, які передають інформацію про рух у приміщеннях. Це дозволяє в реальному часі автоматично керувати освітленням на основі активності користувача.

3.2 Побудова діаграми розгортання
Діаграма розгортання відображає фізичну структуру системи інтелектуального освітлення та спосіб взаємодії між її ключовими апаратними й програмними компонентами. Вона дозволяє зрозуміти, як логічні модулі розміщуються на пристроях і обмінюються даними у процесі виконання. Побудована діаграма розгортання наведена на рисунку Б.4 у додатку Б.
Центральним елементом системи виступає сервер, реалізований на базі Flask. Він виконує функції обробки HTTP-запитів від клієнтських додатків, обробки MQTT-повідомлень від сенсорів, аналітики зібраних даних та управління резервним копіюванням. До складу серверного пристрою входять такі артефакти, як REST API, MQTT Handler, Analytics Engine та Backup System. Сервер виступає як посередник між клієнтами, сенсорами та базою даних.
IoT Sensor є пристроєм збору даних, який містить два основні програмні компоненти – Motion Detector Firmware для виявлення руху та MQTT Publisher для передачі зібраної інформації через протокол MQTT. Сенсор безпосередньо взаємодіє із сервером, надсилаючи дані, які надалі використовуються для активації або деактивації освітлення, а також для генерації аналітики.
Web Client – це користувацький інтерфейс, що реалізований на основі вебтехнологій. Він складається з трьох артефактів: React UI (основний інтерфейс користувача), Device Control Panel (панель керування пристроями) та Energy Analytics View (модуль перегляду аналітики енергоспоживання). Клієнт з’єднується з сервером через HTTPS, використовуючи REST-запити для доступу до функціоналу системи.
Mobile Client реалізовано як Kotlin-додаток, що забезпечує мобільну взаємодію користувача з системою. Він включає Push Notifications (систему сповіщень), Scheduler Editor (редактор розкладів) та основний додаток Kotlin App. Як і веб-клієнт, мобільний клієнт використовує HTTPS-з’єднання для взаємодії з REST API сервера.
Для зберігання інформації використовується окремий вузол Database, що реалізує PostgreSQL. Сервер взаємодіє з базою даних за допомогою SQL-запитів. У базі зберігається інформація про користувачів, пристрої, налаштування, графіки, звіти та історію активності.
Загальна комунікація між компонентами забезпечується різними протоколами: HTTPS/REST – для взаємодії між клієнтами й сервером, MQTT  – для обміну даними з IoT-пристроями, SQL – для доступу сервера до реляційної бази даних.
Представлена діаграма демонструє модульність системи, її масштабованість та взаємозв’язок усіх логічних блоків, що дозволяє легко адаптувати її до змін функціональних вимог, оновлень чи розширення інфраструктури.

3.3 Опис архітектури серверної частини
Серверна частина програмної системи розроблена на основі мови програмування Python з використанням фреймворку Flask. Архітектура побудована за модульним принципом і реалізує логічне розділення функціональності на контролери, бізнес-логіку, маршрутизацію, взаємодію з базою даних, систему резервного копіювання та обробку повідомлень. Усі компоненти взаємодіють між собою через REST API.
Основні модулі серверної частини включають:
1.	Авторизація та аутентифікація. Реалізовано вхід та реєстрацію користувачів із захистом через JWT-токени. Механізм аутентифікації забезпечує безпечний доступ до захищених ендпоінтів API та розмежування прав доступу для звичайних користувачів та адміністраторів.
2.	Керування профілями користувачів. Користувачі мають можливість переглядати, змінювати свої персональні дані, змінювати пароль, електронну адресу, ім’я тощо. Адміністратор має додаткові повноваження для редагування або видалення будь-якого облікового запису.
3.	Керування IoT-пристроями. Система підтримує додавання, редагування, видалення та перегляд користувацьких розумних пристроїв. Кожен пристрій зберігає свою конфігурацію, історію роботи та налаштування енергоспоживання.
4.	Аналітика пристроїв. Реалізовано модуль збору та обробки даних про використання пристрою: кількість активацій, сумарний час роботи за обраний період, середня тривалість включення та розрахунок спожитої електроенергії. Ці дані зберігаються у базі й доступні користувачу через API у форматі зручних звітів.
5.	Система повідомлень. Сервер генерує повідомлення на основі даних пристроїв, таких як сповіщення про перевищення ліміту енергоспоживання, часте використання пристрою або інші аналітичні події. Ці повідомлення відображаються користувачеві через вебінтерфейс, і можуть бути розширені для відправлення email чи push-нотифікацій.
6.	Модуль адміністративного управління. Адміністратор має доступ до всіх користувачів, може змінювати їх дані, призначати ролі, видаляти облікові записи, переглядати зареєстровані пристрої та маніпулювати системними параметрами.
7.	Система резервного копіювання. Для забезпечення збереження критичних даних реалізовано створення резервних копій бази даних. Адміністратор може створювати нові бекапи вручну або автоматизовано, завантажувати існуючі копії або виконувати відновлення системи з архіву. Це особливо важливо для підтримки стабільності та відновлення системи у разі збоїв.
8.	Обробка запитів та маршрутизація. Запити від клієнтів спрямовуються на відповідні маршрути, які реалізовано у вигляді окремих файлів. Кожен маршрут передає запит до відповідного контролера, де обробляється бізнес-логіка, а потім – до рівня доступу до даних (ORM). Для бази даних використовується PostgreSQL, яка взаємодіє з Flask через ORM SQLAlchemy..
9.	Безпека та перевірка прав доступу. Усі чутливі ендпоінти перевіряють JWT-токени користувачів та розподіляють доступ на основі ролі (адміністратор або звичайний користувач). Це реалізовано через middleware, яке автоматично верифікує заголовки запитів і підключає потрібну логіку безпеки.

3.4 Побудова діаграми прецедентів
UML-діаграма прецедентів у контексті системи інтелектуального освітлення є ключовим інструментом для візуалізації взаємодії користувачів і технічних компонентів із основними функціями програмного забезпечення. Вона дозволяє окреслити функціональні можливості для кожного типу користувача та забезпечує логічне розмежування відповідальностей і прав доступу. Діаграма прецедентів представлена на рисунку Б.3 у додатку Б.
У системі визначено чотири актори: User (звичайний користувач), System Administrator (системний адміністратор), Technical Admin (технічний адміністратор) та IoT Sensor (розумний сенсор). Кожен із них взаємодіє зі специфічним підмноженням функціональних можливостей системи.
User має змогу виконувати кілька ключових дій, серед яких основною є керування освітленням (Manage Lighting). Цей прецедент включає в себе налаштування розкладу роботи пристроїв (Set Schedules), що дозволяє автоматизувати вмикання та вимикання світла у вказаний час. Крім того, користувач може переглядати історію подій (Get Event History), яка включає дані про активність сенсорів і пристроїв. Ця функція також передбачає можливість генерації звітів (Generate Reports), що забезпечує аналітичний огляд динаміки енергоспоживання або кількості активацій. Отримані звіти можна переглядати за допомогою окремого прецеденту View Reports.
System Administrator виконує роль управлінця і має доступ до функцій адміністрування системи. Зокрема, він може керувати користувачами (Manage Users), включаючи створення, редагування, призначення ролей і видалення облікових записів. Також системний адміністратор має змогу додавати та видаляти сенсори (Add/Remove Sensors), що розширює прецедент керування користувачами. Окрім цього, адміністратор може перевіряти статус системи (Check System Status), що дозволяє виявити несправності або переглянути поточний стан роботи пристроїв. Перевірка системного статусу також включає ініціацію генерації звітів для аналізу.
Technical Admin відповідає за стійкість і безпеку системи. Йому доступні функції резервного копіювання даних (Backup Data), відновлення з резервної копії (Restore Data) та міграції бази даних (Migrate Database) у разі зміни середовища розгортання або оновлення системи. Прецедент Restore Data є ключовим у цьому контексті, а Backup Data його розширює (через зв’язок <<extend>>), оскільки копіювання зазвичай передує відновленню. Аналогічно, Migrate Database передбачає зміну або переміщення бази в межах інфраструктури.
IoT Sensor виступає як автоматичний технічний актор. Він ініціює надсилання сигналу про рух (Send Movement Signal), що є основним тригером для вмикання освітлення (Activate Lighting). У разі зникнення руху сенсор може також ініціювати вимкнення освітлення (Deactivate Lighting), що позначено на діаграмі як розширення основного сигналу про рух. Завдяки цим автоматизованим прецедентам система реагує на фізичні зміни в навколишньому середовищі без участі користувача.
На діаграмі використано залежності типу <<include>> та <<extend>> для кращого структурування логіки. Наприклад, <<include>> використовується між Manage Lighting і Set Schedules, а також між Get Event History і Generate Reports, оскільки ці прецеденти логічно є складовими ширших функцій. <<extend>> використовується там, де функціональність активується в певних умовах, як-от у випадках Backup Data → Restore Data або Send Movement Signal → Deactivate Lighting.
Загалом, діаграма демонструє збалансований поділ відповідальностей між користувачем, адміністративним персоналом і технічними компонентами системи. Така структура дозволяє досягти високого рівня модульності, безпеки, відмовостійкості та адаптивності в умовах масштабування або розширення функціональності системи.

3.5 Побудова ER-діаграми
ER-діаграма відображає структуру бази даних, включаючи сутності, атрибути, ключі та зв’язки між таблицями. Було створено ER-діаграму програмної системи інтелектуального освітлення, що представлена на рисунку Б.2 у додатку Б. Вона демонструє логічну модель даних, яка лежить в основі серверної частини проєкту, та показує, як інформація про користувачів, пристрої й аналітику зберігається і обробляється.
Сутність Users зберігає базову інформацію про користувачів системи, включаючи email, пароль, ім’я, прізвище та ознаку адміністратора. Ця таблиця має зв’язок 1:N із таблицею Sessions, що використовується для зберігання авторизаційних сесій, кожна з яких пов’язана з конкретним користувачем.
Таблиця IotDevices містить дані про підключені до системи пристрої, включаючи унікальний ідентифікатор, ім’я пристрою та API-ключ для його авторизації. Кожен пристрій пов’язаний із конкретним користувачем через зовнішній ключ UserID, що реалізує зв’язок типу 1:N з таблицею Users.
Таблиця DeviceConfigurations містить налаштування кожного пристрою, включаючи статус активності, режим автоматичного керування та вартість електроенергії. Вона має зв’язок 1:1 з IotDevices, оскільки кожен пристрій має лише одну конфігурацію.
Таблиця DeviceSchedule визначає графіки роботи пристроїв: години вмикання та вимикання. Один пристрій може мати кілька записів графіків, що реалізує зв’язок 1:N з IotDevices.
Таблиця DeviceReports зберігає історію роботи пристрою. Вона містить дані про час активації, статус увімкнення та тривалість роботи. Зв’язок із IotDevices також є 1:N – один пристрій може мати багато записів у журналі активності.
Уся база даних реалізована в реляційній системі PostgreSQL, що забезпечує цілісність і узгодженість даних. Ключові зв’язки між таблицями побудовані через зовнішні ключі, що дає змогу ефективно організувати збереження, пошук і аналітику даних у межах функціоналу серверної частини. Структура бази була спроєктована з урахуванням можливості масштабування системи, її подальшого розвитку та додавання нових модулів, таких як управління сповіщеннями, облік енергоспоживання чи автоматичне резервне копіювання.

3.6 Специфікація REST
Для забезпечення ефективної взаємодії між клієнтською та серверною частинами програмної системи інтелектуального керування освітленням було реалізовано RESTful API, що надає повний набір CRUD-операцій для роботи з основними сутностями: Users, Sessions, IotDevices, DeviceConfigurations, DeviceSchedule та DeviceReports. Кожна з цих сутностей має відповідні маршрути для створення, читання, оновлення та видалення інформації. Основу побудови API складають стандартні методи HTTP (GET, POST, PUT, PATCH, DELETE), що забезпечує просту та передбачувану інтеграцію з будь-яким клієнтським застосунком.
API дозволяє управляти користувачами, виконувати авторизацію, реєстрацію, редагування профілю та зміну паролю, а також працювати з IoT-пристроями: додавати їх до системи, оновлювати налаштування, переглядати аналітику та створювати розклади роботи. Конфігурації пристроїв зберігаються та можуть бути змінені або застосовані до інших пристроїв. Дані про активність пристроїв надсилаються серверу, де формуються звіти, доступні для перегляду та подальшого аналізу. Також реалізовано API для налаштування повідомлень, яке дозволяє змінювати сповіщення користувача, а також керувати способами доставки критичних подій. Окремий набір маршрутів відповідає за систему резервного копіювання – створення, перегляд, завантаження та відновлення бекапів, що дозволяє забезпечити стабільну роботу та захист даних від втрат.
Розроблене API підтримує фільтрацію, сортування, отримання даних за конкретними параметрами, такими як статус пристрою, користувач або часовий діапазон. Усі запити до захищених маршрутів перевіряються за допомогою JWT-токенів. Безпека системи посилена використанням middleware-рівня, який перевіряє права доступу відповідно до ролі користувача: звичайний користувач, адміністратор бізнес-логіки, системний адміністратор або глобальний адміністратор. Відповідно до ролі, користувачі мають змогу виконувати різний набір операцій — від перегляду звітів до повного керування системою, зміни налаштувань конфігурації або резервного копіювання.
Повна специфікація REST-методів наведена в таблиці Г.1 у додатку Г.

3.7 Побудова діаграми компонентів
Діаграма компонентів відображає логічну структуру серверної частини програмної системи, включаючи основні модулі, їх взаємозв’язки та напрямки обміну даними. Вона ілюструє архітектуру системи з позиції модульності, що дозволяє легко масштабувати проєкт, підтримувати та розширювати його у майбутньому. Діаграма компонентів представлена на рисунку Б.5 у додатку Б.
Центральним елементом архітектури є компонент REST API, який виступає посередником між зовнішніми клієнтами (веб- або мобільним застосунком) і внутрішніми модулями логіки. До нього підключені окремі компоненти, кожен з яких реалізує конкретну частину функціональності.
UserAPI та AuthAPI відповідають за керування обліковими записами користувачів та авторизацію. Вони забезпечують створення, редагування профілю, зміну паролів, а також видачу JWT-токенів для доступу до захищених маршрутів.
DevicesAPI і DevicesSelfAPI реалізують функціонал для управління IoT-пристроями, включаючи їх реєстрацію, редагування конфігурацій, перегляд аналітики, додавання розкладів роботи тощо. Вони призначені для звичайних користувачів.
AdminUsersAPI та AdminDevicesAPI – це адміністративні компоненти, що дозволяють адміністратору отримувати доступ до інформації про будь-якого користувача або пристрій, редагувати їх дані та видаляти у разі потреби.
NotificationsAPI обробляє логіку сповіщень, які можуть генеруватися у випадках активації пристроїв, змін конфігурацій або при виникненні умов, що вимагають уваги користувача.
BackupAPI надає можливість створення, перегляду, завантаження та відновлення резервних копій бази даних, що критично важливо для забезпечення збереження та стабільності роботи системи.
AnalyticsModule відповідає за збір та обробку статистичних даних про використання пристроїв. Він взаємодіє з Data Access для отримання звітів і подій з бази даних, проводить розрахунки тривалості роботи пристроїв, енергоспоживання тощо.
MQTT Module обробляє повідомлення, які надходять від фізичних IoT-пристроїв через протокол MQTT. Цей компонент забезпечує асинхронну комунікацію та передачу подій руху, що активують автоматичне освітлення.
Data Access є універсальним посередником між усіма модулями логіки та Database. Він реалізує зчитування, запис, оновлення і видалення даних у таблицях за допомогою ORM SQLAlchemy, підтримує транзакції та забезпечує абстракцію доступу до даних.
Загальна архітектура побудована з урахуванням модульності, де кожен компонент виконує конкретну роль, має чітко визначений інтерфейс і взаємодіє з іншими через REST або MQTT. Такий підхід дозволяє підтримувати систему у чистому стані, забезпечувати повторне використання коду та спрощувати розширення функціоналу у майбутньому.
 
4 ВИСНОВКИ
У результаті виконання лабораторної роботи було створено повнофункціональну серверну частину для інтелектуальної системи керування освітленням з використанням IoT-пристроїв. Реалізовано багаторівневу архітектуру, що включає логічний розподіл на API-шлюз, бізнес-логіку, рівень доступу до даних та конфігураційний модуль. Отримано навички побудови RESTful API, роботи з базами даних, реалізації JWT-автентифікації, а також створення ER-діаграм, діаграм компонентів і специфікацій API.
Було розроблено систему резервного копіювання та реалізовано механізми сповіщення користувачів про події в роботі пристроїв. Спроектована база даних забезпечує логічну цілісність і масштабованість. Для повного розуміння структури системи було побудовано UML-діаграми: діаграму розгортання, компонентів, ER-діаграму, а також діаграму прецедентів. Реалізоване програмне забезпечення відповідає поставленим вимогам та демонструє готовність до подальшого розвитку. 

 
ДОДАТОК А
ВІДЕОЗАПИС

Відеозапис доповіді на YouTube: https://youtu.be/bAaQ8lMIZd8
Хронологічний опис доповіді: 
00:00 – Вступ
00:15 – Опис використаних технологій для реалізації проєкту
00:57 – Опис архітектури серверної частини
07:06 – Тестування авторизації користувачів
08:15 – Тестування API: отримання, додавання та редагування пристроїв
11:42 – Тестування API: отримання звітів
12:16 – Тестування API: отримання, додавання та видалення розкладів
14:47 – Тестування API: видалення пристроїв
15:49 – Тестування API: додавання та отримання резервних копій


ДОДАТОК Б
ГРАФІЧНІ МАТЕРІАЛИ

Рисунок Б.1 — ER-діаграма даних

Рисунок Б.2 — Структура бази даних

Рисунок Б.3 — UML-діаграма прецедентів

Рисунок Б.4 — UML-діаграма розгортання
 
Рисунок Б.5 – UML-діаграма компонентів 


ДОДАТОК В
ПРОГРАМНИЙ КОД

В.1 Математична обробка прикладних даних
GitHub репозиторій: https://github.com/NureHorishniaKateryna/apz-pzpi-22-6-horishnia-kateryna/blob/main/Lab2/pzpi-22-6-horishnia-kateryna-lab2/app.py

 1   @app.get("/api/devices/<int:device_id>/analytics")
 2   def get_device_analytics(path: DevicePath, header: 
     AuthHeaders):
 3       user = auth_user(header.token)
 4   
 5      device = 
        session.query(IotDevice).filter_by(id=path.device_id,     
        user=user).join(DeviceConfiguration).scalar()
 6   
 7       base_query = session.query(DeviceReport.enabled_for)\
 8     .filter_by(device=device)
       .filter(DeviceReport.enabled_for != None)
 9   
10       this_month = base_query.filter(extract("month", 
         DeviceReport.time) == date.today().month)
11       last_28_days = base_query.filter(DeviceReport.time > 
         (date.today() - timedelta(days=28)))
12   
13       this_month_count = this_month.count()
14       last_28_days_count = last_28_days.count()
15        this_month_enabled_time = sum(*zip(*this_month.all()))
16       last_28_days_enabled_time = 
         sum(*zip(*last_28_days.all()))
17   
18       _1_HOUR = 60 * 60
19   
20       this_month_electricity_consumption = 
         this_month_enabled_time / _1_HOUR * POWER_CONSUMPTION
21       last_28_days_electricity_consumption = 
       last_28_days_enabled_time / _1_HOUR * POWER_CONSUMPTION
22   
23       return {
24           "this_month": {
25               "enable_count": this_month_count,
26               "total_enabled_time": this_month_enabled_time,
27               "average_enabled_time": 
                 int(this_month_enabled_time / 
                 this_month_count) if this_month_count else 0,
28               "electricity_consumption": 
                 this_month_electricity_consumption,
29               "electricity_price": 
                 this_month_electricity_consumption / 1000 * 
                 device.configuration.electricity_price,
30           },
31           "last_28_days": {
32               "enable_count": last_28_days_count,
33               "total_enabled_time": last_28_days_enabled_time,
34               "average_enabled_time": 
                 int(last_28_days_enabled_time / 
             last_28_days_count) if last_28_days_count else 0,
35               "electricity_consumption": 
                 last_28_days_electricity_consumption,
36               "electricity_price": 
                 last_28_days_electricity_consumption / 1000 * 
                 device.configuration.electricity_price,
37           }
38       }

В.2 Адміністрування бізнес-логіки системи
GitHub репозиторій: https://github.com/NureHorishniaKateryna/apz-pzpi-22-6-horishnia-kateryna/blob/main/Lab2/pzpi-22-6-horishnia-kateryna-lab2/app.py

 1   @app.get("/api/admin/users")
 2   def admin_get_users(query: PaginationQuery, header:
     AuthHeaders):
 3       auth_admin(header.token)
 4   
 5       query_ = session.query(User).order_by("id")
 6   
 7       count = query_.count()
 8       query_ =
         query_.limit(query.page_size).offset((query.page -  
         1) * query.page_size)
 9   
10       return {
11           "count": count,
12           "result": [user.to_json() for user in 
            query_.all()],
13       }
14   
15   
16   @app.get("/api/admin/users/<int:user_id>")
17   def admin_get_user(path: UserPath, header: AuthHeaders):
18       auth_admin(header.token)
19   
20       user = 
      session.query(User).filter_by(id=path.user_id).scalar()
21       if user is None:
22           return {"error": "Unknown user!"}, 404
23   
24       return user.to_json()
25   
26   
27   @app.patch("/api/admin/users/<int:user_id>")
28   def admin_edit_user(path: UserPath, body: 
     EditUserRequest, header: AuthHeaders):
29       auth_admin(header.token)
30   
31       user = 
      session.query(User).filter_by(id=path.user_id).scalar()
32       if user is None:
33           return {"error": "Unknown user!"}, 404
34   
35       if body.email is not None:
36           user.email = body.email
37       if body.password is not None:
38           user.password = 
bcrypt.hashpw(body.password.encode("utf8"), bcrypt.gensalt())
39       if body.first_name is not None:
40           user.first_name = body.first_name
41       if body.last_name is not None:
42           user.last_name = body.last_name
43       if body.is_admin is not None:
44           user.is_admin = body.is_admin
45   
46       if body.email is not None or body.password is not 
         None or body.first_name is not None \
47               or body.last_name is not None or 
                 body.is_admin is not None:
48           session.commit()
49   
50       return user.to_json()
51   
52   
53   @app.delete("/api/admin/users/<int:user_id>")
54   def admin_delete_user(path: UserPath, header: 
     AuthHeaders):
55       auth_admin(header.token)
56   
57    session.query(User).filter_by(id=path.user_id).delete()
58       return "", 204

В.3 Резервне копіювання користувацьких даних
GitHub репозиторій: https://github.com/NureHorishniaKateryna/apz-pzpi-22-6-horishnia-kateryna/blob/main/Lab2/pzpi-22-6-horishnia-kateryna-lab2/app.py

 1   @app.get("/api/admin/system/backups")
 2   def list_backups(header: AuthHeaders):
 3       auth_admin(header.token)
 4   
 5       db_uri = environ["DATABASE"]
 6       backup_prefix = db_uri.split("://")[0]
 7   


 8       backups = 
         glob.glob(f"{BACKUPS_DIR}/{backup_prefix}_*.bak", 
         recursive=False, include_hidden=False)
 9       backups = sorted(backups, reverse=True)
10       backups = map(lambda path: 
         str(Path(path).relative_to(BACKUPS_DIR)), backups)
11       backups = list(backups)
12   
13       return backups
14   
15   
16   @app.post("/api/admin/system/backups")
17   def create_backup(header: AuthHeaders):
18       auth_admin(header.token)
19   
20       db_uri = environ["DATABASE"]
21       backup_prefix = db_uri.split("://")[0]
22       backup_name = datetime.now(UTC).strftime("%d%m%Y-
         %H%M%S")
23       backup_file = f"{backup_prefix}_{backup_name}.bak"
24   
25       if db_uri.startswith("sqlite:///"):
26           db_path = db_uri.replace("sqlite:///", "")
27           shutil.copy2(db_path, BACKUPS_DIR / backup_file)
28       elif db_uri.startswith("postgresql://"):
29           parsed = db_uri.replace("postgresql://", "")
30           user_pass, host_db = parsed.split("@")
31           user, password = user_pass.split(":")
32           host, dbname = host_db.split("/")
33   
34           dump_env = environ.copy()
35           dump_env["PGPASSWORD"] = password
36   
37           cmd = ["pg_dump", "-U", user, "-h", host, "-F", 
            "c", "-f", str(BACKUPS_DIR / backup_file), dbname]
38           subprocess.run(cmd, check=True, env=dump_env)
39       else:
40           return {"error": "Unsupported database type"}, 
             400
41   
42       return "", 204
43   
44   
45   @app.route("/api/admin/system/backups/<string:filename>", 
     methods=["GET"])
46   def download_backup(filename: str):
47       auth_admin(request.headers.get("token", ""))
48   
49       if "/" in filename or "\\" in filename:
50           return {"error": "Unknown backup"}, 404
51   
52       path = BACKUPS_DIR / filename
53       if not path.exists():
54           return {"error": "Unknown backup"}, 404
55   
56       return send_file(path, as_attachment=True)
57   
58   
59   @app.route("/api/admin/system/backups/<string:filename>", 
     methods=["DELETE"])
60   def delete_backup(filename: str):
61       auth_admin(request.headers.get("token", ""))
62   
63       if "/" in filename or "\\" in filename:
64           return {"error": "Unknown backup"}, 404
65   
66       path = BACKUPS_DIR / filename
67       if not path.exists():
68           return {"error": "Unknown backup"}, 404
69   
70       path.unlink(missing_ok=True)
71       return "", 204
72   
73   
74   @app.route("/api/admin/system/backups/<string:filename>
     /restore", methods=["POST"])
75   def restore_backup(filename: str):
76       auth_admin(request.headers.get("token", ""))
77   
78       if "/" in filename or "\\" in filename:
79           return {"error": "Unknown backup"}, 404
80   
81       db_uri = environ["DATABASE"]
82       backup_prefix = db_uri.split("://")[0]
83       backup_file = 
         f"{backup_prefix}_{filename.split('_')[1]}"
84       backup_path = BACKUPS_DIR / backup_file
85   
86       if not backup_path.exists():
87           return {"error": "Unknown backup"}, 404
88   
89       if db_uri.startswith("sqlite:///"):
90           db_path = db_uri.replace("sqlite:///", "")
91           shutil.copy2(backup_path, db_path)
92   
93       elif db_uri.startswith("postgresql://"):
94           parsed = db_uri.replace("postgresql://", "")
95           user_pass, host_db = parsed.split("@")
96           user, password = user_pass.split(":")
97           host, dbname = host_db.split("/")
98   
99           dump_env = environ.copy()
100           dump_env["PGPASSWORD"] = password
101   
102           user_host = ["-U", user, "-h", host]
103           subprocess.run(["dropdb", *user_host, dbname], 
              check=True, env=dump_env)
104            subprocess.run(["createdb", *user_host, dbname], 
              check=True, env=dump_env)
105           subprocess.run(["pg_restore", *user_host, "-d", 
              dbname, str(backup_path)], check=True, 
              env=dump_env)
106       else:
107           return {"error": "Unsupported database type"}, 
              400
108   
109       return "", 204

 
ДОДАТОК Г
СПЕЦИФІКАЦІЯ REST

Таблиця Г.1 – Специфікація API
Метод	Маршрут	Опис
GET	/api/admin/devices	Отримання списку всіх IoT-пристроїв, підключених до системи.
DELETE	/api/admin/devices/{device_id}	Видалення конкретного IoT-пристрою за його ID.
GET	/api/admin/devices/{device_id}	Отримання інформації про конкретний IoT-пристрій за його ID.
PATCH	/api/admin/devices/{device_id}	Оновлення інформації про IoT-пристрій за його ID.
GET	/api/admin/users	Отримання списку всіх користувачів системи.
DELETE	/api/admin/users/{user_id}	Видалення конкретного користувача за його ID.
GET	/api/admin/users/{user_id}	Отримання інформації про конкретного користувача за його ID.
PATCH	/api/admin/users/{user_id}	Оновлення профілю користувача за його ID.
POST	/api/auth/login	Авторизація користувача та отримання JWT токену.
POST	/api/auth/register	Реєстрація нового користувача.
GET	/api/device/config	Отримання конфігурації пристрою.
POST	/api/device/report	Створення звіту про роботу пристрою.
GET	/api/device/schedule	Отримання розкладу роботи пристроїв.
GET	/api/devices	Отримання списку всіх IoT-пристроїв.
POST	/api/devices	Додавання нового IoT-пристрою в систему.
DELETE	/api/devices/{device_id}	Видалення конкретного IoT-пристрою за його ID.
GET	/api/devices/{device_id}	Отримання інформації про конкретний IoT-пристрої за його ID.
PATCH	/api/devices/{device_id}	Оновлення інформації про IoT-пристрої за його ID.
GET	/api/devices/{device_id}/analytics	Отримання аналітики по конкретному IoT-пристрою.
PATCH	/api/devices/{device_id}/config	Оновлення конфігурації конкретного IoT-пристрою.
GET	/api/devices/{device_id}/reports	Отримання звітів по конкретному IoT-пристрою.
GET	/api/devices/{device_id}/schedule	Отримання розкладу роботи конкретного IoT-пристрою.
POST	/api/devices/{device_id}/schedule	Додавання нового розкладу для конкретного IoT-пристрою.
DELETE	/api/devices/{device_id}/schedule/{schedule_id}	Видалення конкретного розкладу для IoT-пристрою.
GET	/api/admin/system/backups	Отримання списку всіх доступних резервних копій системи
POST	/api/admin/system/backups	Створення нової резервної копії системи
